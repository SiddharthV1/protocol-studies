# Overview

Beyond execution layer's fundamental role of transaction execution, the execution layer client undertakes several critical responsibilities. These include verification of the blockchain data and storing its local copy, facilitating network communication through gossip protocols with other execution layer clients, maintaining a transaction pool, and fulfilling the consensus layer's requirements that drive its functionality. This multifaceted operation ensures the robustness and integrity of the Ethereum network.

The client's architecture is built around a variety of specific standards, each of which plays a unique role in the overall functionality. The execution engine is located at the top, driving the execution layer, which in turn is driven by the consensus layer. The execution layer runs on top of devp2p, the networking layer, which is initialized by providing legitimate boot nodes that provide an initial access point into the network. When we call one of the engine API methods, such as fork choice updated, we can download blocks from peers by subscribing to topics like our preferred mode of sync.

In addition, the networking layer is responsible for transmitting and receiving remote transactions into the transaction pool. These transactions are then ordered inside the pool based on factors such as the priority fee, transaction validity, and whether they are local or remote. Local transactions are given priority over remote ones. Furthermore, the block level state transition function from the specifications, which includes header and state root verification, as well as the transaction level state transition function, is often handled by the following components: The internal consensus engine is often responsible for header verification, while the EVM/state processor is in charge of transaction-level state transitions. In addition to all of this, the execution engine is in charge of preserving state in a key value DB, which is responsible for storing the Merkle-Patricia State Tries and is initialized by passing it a genesis file, which represents the first block of the chain we want to keep in sync with.

Different clients employ diverse approaches to managing the components inside the architecture, as an illustration. During a full sync in Geth, the downloader applies the block-level state transition function to the downloaded blocks. On the other hand, Reth only verifies the consensus engine on the downloaded blocks and only executes the transaction-level state transition function on the blocks it adds to its blockchain tree. Furthermore, although Geth's structure is categorized as monolithic, it is crucial to acknowledge that certain functionalities included in Geth may not be present in alternative clients, such as Geth's lightclient capabilities. Considering this, the suggested document structure should designate all components that have similarities with current major clients as H2 headers. A concise summary of each component's responsibility should be provided below the header, followed by the use of H3 headers to indicate client-specific code links and insights related to the topic.

Proposed page scheme:

## Component Name

Overview

### Client (geth, reth etc)

Client specific code links and write up

TODO: Add architecture visual

## Engine

The execution layer client acts as an _execution engine_ and exposes the Engine API, an authenticated endpoint, which connects to the consensus layer client. The engine is also referred to as the external consensus engine by the execution layer clients. The execution layer client can be only driven by a single consensus layer, but a consensus layer client implementations can connect to multiple execution layer clients for redundancy. The Engine API uses the JSON-RPC interface over HTTP and requires authentication via a [JWT](https://jwt.io/introduction) token. Additionally the Engine JSON-RPC is not exposed to anyone besides the consensus layer. However, it's important to note that the JWT is primarily used for authenticating the Payload, i.e. Sender is the consensus layer client, it does not encrypt the traffic.

TODO: breif overview on new payload and forchoice

## Boot Nodes and Network Bootup

## Execution Layer's BlockChain

## Internal Consensus Engines

The execution layer has its own consensus engine to work with its own copy of the beacon chain. The execution layer consensus engine is known as ethone and has about half the functionality of the full fledged consensus engine of the consensus layer.

### Geth

In Geth, the algorithm agnostic interface of the consensus engine in execution layer has these functions

| Function                                                                                                               | Beacon (Proof-of-stake)                                                                                                                                                                                                                                                                                                                  | Clique (Proof-of-authority)                                                                                                                                                                                                                                                                                                                                                                                                                                                | Ethash (Proof-of-work) |
| ---------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------- |
| **Author**: Eth address of the block minter                                                                            | If the header is a PoS header (header difficulty is set to 0) then we return the header's coinbase else we send the header for processing to the beacon's ethone engine (clique or ethash)                                                                                                                                               | Retrieves the account address the minted the block. In Clique , this done by ecrerecover that recovers the public key from the header's extraData                                                                                                                                                                                                                                                                                                                          |                        |
| **Verify Header(s)**: Takes a batch of headers and verifies them based on the rules of the current consensus engine. : | Split the headers based on [Terminal Total difficulty](https://eips.ethereum.org/EIPS/eip-3675#definitions) into pre and post TTD batches . Verify the pre batches with the ethone engine and the post by beacon's verify header                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                        |
|                                                                                                                        | Here we perform block header verification similar to the one in the [execution layer-Specs](wiki/EL/el-specs?id=block-header-validation) wiki page                                                                                                                                                                                       | We verify the time of the header is not greater than system time.                                                                                                                                                                                                                                                                                                                                                                                                          |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | If it is a checkpoint (1'st slot of epoch) block then ensure it has no beneficiary.                                                                                                                                                                                                                                                                                                                                                                                        |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | The header nonce can be either 0x00..0 (represents vote to add signer) or 0xff..f (represents vote to drop signer ), At checkpoints we can only drop the signer.                                                                                                                                                                                                                                                                                                           |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | The extradata length mush account for vanity + the signature. At Checkpoints, the extradata contains the signer list + signature.                                                                                                                                                                                                                                                                                                                                          |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | Header gas checks.                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | Retrieve the snapshot (config: Config for Consensus engine, signatureLRUCache: Cache speed up ecrecover, SnapshotBlockNumber, SnapshotBlockHash, Signers: authorized signers at this point , RecentSigners: used for spam protections, Votes : Chronologically ordered votes that were cast, VoteTally )                                                                                                                                                                   |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | On checkpoint blocks verify the signers in the snapshot against the extradata                                                                                                                                                                                                                                                                                                                                                                                              |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | Verify Seal : Verifies if all the requirements are met for the signature contained in the header. This is recovered using the header, and the recent signers in the Clique object, then we check the signer is included in the snapshot.signers obtained in step 6.                                                                                                                                                                                                        |                        |     |
| **Verify Uncles**                                                                                                      | If the Header is a PoS header verify the length of uncles is 0. If not PoS, ethone's verify uncles is called                                                                                                                                                                                                                             | In Clique no uncles should be present                                                                                                                                                                                                                                                                                                                                                                                                                                      |                        |
| **Prepare**: Initializes the consensus fields of a block's header.                                                     | If TTD is reached we set the header's difficulty to beacon's difficulty(0) , else we call ethone's prepare                                                                                                                                                                                                                               | Assemble the voting snapshot by providing the parent hash and number.We iterate backwards from the block number, if we reach genesis or if we are using a light client (which doesn't store parent blocks) or if we reach an epoch by traversing backwards or if the headers traversed are greater than the value for soft Finality (which implies the segment is considered immutable) we create a snapshot at the checkpoint we have arrived at during reverse iteration |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | If we are not at the end of an epoch we iterate over the addresses in proposals field of the snap object and randomly select one as the coinbase; voting auth-vote if the proposal is authorized else we cast a drop vote.                                                                                                                                                                                                                                                 |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | Set the header difficulty based on signer's turn (2 if the signer is in turn and 1 if not)                                                                                                                                                                                                                                                                                                                                                                                 |                        |
|                                                                                                                        |                                                                                                                                                                                                                                                                                                                                          | Ensure the extradata has all the required components such as extraVanity, list of signers if the block is at the end of the epoch. We add this to the Header.extraData.                                                                                                                                                                                                                                                                                                    |                        |
| **Finalize**: Post state modifications, state db might get updated, this does not assemble the block                   | If not a PoS header we call ethone's finalize else we iterate over the block's withdrawals, converting their amounts from wei to gwei and then making a state modification that adds the amount to the address in the current withdrawal                                                                                                 | Clique has no post-transaction consensus rules, no block rewards in proof of authority                                                                                                                                                                                                                                                                                                                                                                                     |                        |
| **FinalizeAndAssemble**: Finalises and assemble the final block                                                        | If not a PoS header we call ethone's FinalizeAndAssemble, If withdrawals are nil, and the block is after the shanghai fork, we add an empty withdrawals object. Then we call finalize, compute the state root and assign it to header's root and build a new block block with the header, transactions, uncles, receipts and withdrawals | Ensure no withdrawals are present, call finalize, compute the state root of our stateDB and assign it to Header's root and build a new block with the header, transactions and receipts                                                                                                                                                                                                                                                                                    |                        |
| **Seal**: Generates a sealing request for a block and pushes the request into the given channel                        | If Not a PoS header we call ethone's seal, else we do nothing and return nil (seal verification is done by the external consensus engine)                                                                                                                                                                                                | Ensure it's not the genesis block, retrieve the snapshot and verify that we are both authorized to sign and are not part of the recent signers, time synchronize our turn , sign with the sign function and propagate the sealed block on the given channel                                                                                                                                                                                                                |                        |
| **SealHash**: Hash of the block prior to sealing                                                                       |                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                        |
| **CalcDifficulty**: Difficulty adjustment algorithm, returns the difficulty of the new block                           |                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                        |

## Sync

## Downloader

## Transaction Pools

In Ethereum two primary types of transaction pools are recognized:

1. **Legacy Pools**: Managed by Geth, these pools employ price-sorted heaps or priority queues to organize transactions based on their price. Specifically, transactions are arranged using two heaps: one prioritizes the effective tip for the upcoming block, and the other focuses on the gas fee cap. During periods of saturation, the larger of these two heaps is selected for the eviction of transactions, optimizing the pool's efficiency and responsiveness. [urgent and floating heaps](https://github.com/ethereum/go-ethereum/blob/064f37d6f67a012eea0bf8d410346fb1684004b4/core/txpool/legacypool/list.go#L525)

2. **Blob Pools**: Unlike legacy pools, blob pools maintain a priority heap for transaction eviction but incorporate distinct mechanisms for operation. Notably, the implementation of blob pools is well-documented, with an extensive comments section available for review [here](https://github.com/ethereum/go-ethereum/blob/064f37d6f67a012eea0bf8d410346fb1684004b4/core/txpool/blobpool/blobpool.go#L132). A key feature of blob pools is the use of logarithmic functions in their eviction queues.

## EVM

## DevP2P

## MPT
